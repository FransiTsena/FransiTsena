<p align="center">
  <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExZXYxZDU3dDJobTl1dHJtM2ZtdG1kMGdyODdpcTFxd3N1ZzIxNzNhdCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/13HgwGsXF0aiGY/giphy.gif" width="300" />
</p>

<h1 align="center">Hey, Iâ€™m Fransi</h1>

<p align="center">
  <img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=900&color=36BCF7&center=true&vCenter=true&width=600&lines=Building+systems+that+survives+real+traffic;Microservices/Monoliths" alt="Typing SVG" />
</p>

<p align="center">
  <b>Some people chase frameworks. I chase system behavior.</b><br>
  Give me a blank repo and Iâ€™ll ship a fault-tolerant, event-driven, horizontally scalable system that stays calm when traffic spikes.
</p>

---

### What I Actually Build
I design and ship **production systems**, the kind that handle real users, real money, and real chaos.

Not just writing APIs. I design **how services talk**, **how data moves**, and **what breaks first** (then I fix that).

Monoliths are fine.  
**Microservices are inevitable** once scale shows up uninvited.

---

### How I Think About Systems
> *â€œIf it doesnâ€™t scale, itâ€™s a prototype.â€*

I optimize for:
- **Failure tolerance** over happy paths  
- **Async communication** over tight coupling  
- **Observability** so bugs canâ€™t hide  

Clean code is nice.  
**Predictable systems under pressure** are better.

---

### Architecture I Gravitate Toward
- **Microservices** with clear ownership and boundaries  
- **Event-driven flows** using Kafka instead of synchronous panic  
- **Redis** for caching, rate-limiting, queues, and fast state  
- **Stateless services** that scale horizontally without drama  

Services should be replaceable.  
Deployments should be boring.  
Incidents should be rare â€” and explainable.

---

### The Actual Stack
| Layer | Tools I Trust |
| :--- | :--- |
| **Frontend** | Flutter, Dart, React, TypeScript |
| **Backend** | Go, Node.js, NestJS, REST & Dat |
| **Messaging** | Kafka, RabbitMQ (events > requests) |
| **Caching & Speed** | Redis (cache, pub/sub, locks, rate limits) |
| **Databases** | SQL & NoSQL (chosen intentionally, not randomly) |
| **Infra** | Docker, Kubernetes, AWS, GCP |
| **DevOps Brain** | CI/CD, IaC, monitoring, logs, metrics |

---

If one service dies, the system shrugs and keeps moving.

Thatâ€™s the goal.

---

### ğŸ® Current Fixations
- ğŸ¤– **AI agents** acting like junior engineers (with supervision)  
- ğŸ§µ **Async-first architectures** that donâ€™t block on feelings  
- ğŸŒ **Edge deployments** because users hate waiting  
- ğŸ–¥ï¸ **Terminal + anime OSTs** (statistically improves focus)

---

### ğŸ“ˆ Proof I Touch Real Code
<p align="center">
  <img src="https://github-readme-stats.vercel.app/api?username=fransitsena&show_icons=true&theme=tokyonight" height="150" />
  <img src="https://github-readme-stats.vercel.app/api/top-langs/?username=fransitsena&layout=compact&theme=tokyonight" height="150" />
</p>

---

### ğŸ“« Letâ€™s Talk Systems
<p align="center">
  <a href="https://www.linkedin.com/in/fransi-t-185452301">
    <img src="https://img.shields.io/badge/LinkedIn-Architecting%20Reality-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" />
  </a>
</p>

<p align="center">
  <img src="https://media.giphy.com/media/1gLZ32bMP5pY52PBsm/giphy.gif" width="480" />
  <br>
  <i>â€œDesign for failure. Ship with confidence. Let metrics tell the truth.â€</i>
</p>
